/*
DRACOON API

REST Web Services for DRACOON<br><br>This page provides an overview of all available and documented DRACOON APIs, which are grouped by tags.<br>Each tag provides a collection of APIs that are intended for a specific area of the DRACOON.<br><br><a title='Developer Information' href='https://developer.dracoon.com'>Developer Information</a>&emsp;&emsp;<a title='Get SDKs on GitHub' href='https://github.com/dracoon'>Get SDKs on GitHub</a><br><br><a title='Terms of service' href='https://www.dracoon.com/terms/general-terms-and-conditions/'>Terms of service</a>

API version: 5.3.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
)

// PublicAPIService PublicAPI service
type PublicAPIService service

type ApiCancelFileUploadViaShareRequest struct {
	ctx        context.Context
	ApiService *PublicAPIService
	accessKey  string
	uploadId   string
}

func (r ApiCancelFileUploadViaShareRequest) Execute() (*http.Response, error) {
	return r.ApiService.CancelFileUploadViaShareExecute(r)
}

/*
CancelFileUploadViaShare Cancel file upload

### Description:
Abort (chunked) upload via Upload Share.

### Precondition:
Valid Upload ID.

### Postcondition:
Aborts upload and invalidates upload ID / token.

### Further Information:
None.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accessKey Access key
	@param uploadId Upload channel ID
	@return ApiCancelFileUploadViaShareRequest
*/
func (a *PublicAPIService) CancelFileUploadViaShare(ctx context.Context, accessKey string, uploadId string) ApiCancelFileUploadViaShareRequest {
	return ApiCancelFileUploadViaShareRequest{
		ApiService: a,
		ctx:        ctx,
		accessKey:  accessKey,
		uploadId:   uploadId,
	}
}

// Execute executes the request
func (a *PublicAPIService) CancelFileUploadViaShareExecute(r ApiCancelFileUploadViaShareRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.CancelFileUploadViaShare")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/public/shares/uploads/{access_key}/{upload_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"access_key"+"}", url.PathEscape(parameterValueToString(r.accessKey, "accessKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"upload_id"+"}", url.PathEscape(parameterValueToString(r.uploadId, "uploadId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 504 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 507 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCheckPublicDownloadSharePasswordRequest struct {
	ctx        context.Context
	ApiService *PublicAPIService
	accessKey  string
	password   *string
}

// Download share password
func (r ApiCheckPublicDownloadSharePasswordRequest) Password(password string) ApiCheckPublicDownloadSharePasswordRequest {
	r.password = &password
	return r
}

func (r ApiCheckPublicDownloadSharePasswordRequest) Execute() (*http.Response, error) {
	return r.ApiService.CheckPublicDownloadSharePasswordExecute(r)
}

/*
CheckPublicDownloadSharePassword Check public Download Share password

<h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.36.0</h3>

### Description:
Check password for a public Download Share

### Precondition:
None.

### Postcondition:
None.

### Further Information:
None.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accessKey Access key
	@return ApiCheckPublicDownloadSharePasswordRequest
*/
func (a *PublicAPIService) CheckPublicDownloadSharePassword(ctx context.Context, accessKey string) ApiCheckPublicDownloadSharePasswordRequest {
	return ApiCheckPublicDownloadSharePasswordRequest{
		ApiService: a,
		ctx:        ctx,
		accessKey:  accessKey,
	}
}

// Execute executes the request
func (a *PublicAPIService) CheckPublicDownloadSharePasswordExecute(r ApiCheckPublicDownloadSharePasswordRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodHead
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.CheckPublicDownloadSharePassword")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/public/shares/downloads/{access_key}"
	localVarPath = strings.Replace(localVarPath, "{"+"access_key"+"}", url.PathEscape(parameterValueToString(r.accessKey, "accessKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.password != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "password", r.password, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCompleteFileUploadViaShareRequest struct {
	ctx             context.Context
	ApiService      *PublicAPIService
	accessKey       string
	uploadId        string
	xSdsDateFormat  *string
	userFileKeyList *UserFileKeyList
}

// Date time format (cf. [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) &amp; [leettime.de](http://leettime.de/))
func (r ApiCompleteFileUploadViaShareRequest) XSdsDateFormat(xSdsDateFormat string) ApiCompleteFileUploadViaShareRequest {
	r.xSdsDateFormat = &xSdsDateFormat
	return r
}

func (r ApiCompleteFileUploadViaShareRequest) UserFileKeyList(userFileKeyList UserFileKeyList) ApiCompleteFileUploadViaShareRequest {
	r.userFileKeyList = &userFileKeyList
	return r
}

func (r ApiCompleteFileUploadViaShareRequest) Execute() (*PublicUploadedFileData, *http.Response, error) {
	return r.ApiService.CompleteFileUploadViaShareExecute(r)
}

/*
CompleteFileUploadViaShare Complete file upload

### Description:
Finalize (chunked) upload via Upload Share.

### Precondition:
Valid upload ID.
Only returns users that owns one of the following permissions: <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage download share</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage upload share</span>

### Postcondition:
Finalizes upload.

### Further Information:
Chunked uploads (range requests) are supported.

Please ensure that all chunks have been transferred correctly before finishing the upload.
If file hash has been created in time a `201 Created` will be responded and hash will be part of response, otherwise it will be a `202 Accepted` without it.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accessKey Access key
	@param uploadId Upload channel ID
	@return ApiCompleteFileUploadViaShareRequest
*/
func (a *PublicAPIService) CompleteFileUploadViaShare(ctx context.Context, accessKey string, uploadId string) ApiCompleteFileUploadViaShareRequest {
	return ApiCompleteFileUploadViaShareRequest{
		ApiService: a,
		ctx:        ctx,
		accessKey:  accessKey,
		uploadId:   uploadId,
	}
}

// Execute executes the request
//
//	@return PublicUploadedFileData
func (a *PublicAPIService) CompleteFileUploadViaShareExecute(r ApiCompleteFileUploadViaShareRequest) (*PublicUploadedFileData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PublicUploadedFileData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.CompleteFileUploadViaShare")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/public/shares/uploads/{access_key}/{upload_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"access_key"+"}", url.PathEscape(parameterValueToString(r.accessKey, "accessKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"upload_id"+"}", url.PathEscape(parameterValueToString(r.uploadId, "uploadId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xSdsDateFormat != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Sds-Date-Format", r.xSdsDateFormat, "")
	}
	// body params
	localVarPostBody = r.userFileKeyList
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 504 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 507 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCompleteS3FileUploadViaShareRequest struct {
	ctx                          context.Context
	ApiService                   *PublicAPIService
	accessKey                    string
	uploadId                     string
	completeS3ShareUploadRequest *CompleteS3ShareUploadRequest
}

func (r ApiCompleteS3FileUploadViaShareRequest) CompleteS3ShareUploadRequest(completeS3ShareUploadRequest CompleteS3ShareUploadRequest) ApiCompleteS3FileUploadViaShareRequest {
	r.completeS3ShareUploadRequest = &completeS3ShareUploadRequest
	return r
}

func (r ApiCompleteS3FileUploadViaShareRequest) Execute() (*http.Response, error) {
	return r.ApiService.CompleteS3FileUploadViaShareExecute(r)
}

/*
CompleteS3FileUploadViaShare Complete S3 file upload

<h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.15.0</h3>

### Description:
Finishes a S3 file upload and closes the corresponding upload channel.

### Precondition:
Valid upload ID.
Only returns users that owns one of the following permissions: <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage download share</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage upload share</span>

### Postcondition:
Upload channel is closed. S3 multipart upload request is completed.

### Further Information:
None.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accessKey Access key
	@param uploadId Upload channel ID
	@return ApiCompleteS3FileUploadViaShareRequest
*/
func (a *PublicAPIService) CompleteS3FileUploadViaShare(ctx context.Context, accessKey string, uploadId string) ApiCompleteS3FileUploadViaShareRequest {
	return ApiCompleteS3FileUploadViaShareRequest{
		ApiService: a,
		ctx:        ctx,
		accessKey:  accessKey,
		uploadId:   uploadId,
	}
}

// Execute executes the request
func (a *PublicAPIService) CompleteS3FileUploadViaShareExecute(r ApiCompleteS3FileUploadViaShareRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.CompleteS3FileUploadViaShare")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/public/shares/uploads/{access_key}/{upload_id}/s3"
	localVarPath = strings.Replace(localVarPath, "{"+"access_key"+"}", url.PathEscape(parameterValueToString(r.accessKey, "accessKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"upload_id"+"}", url.PathEscape(parameterValueToString(r.uploadId, "uploadId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.completeS3ShareUploadRequest == nil {
		return nil, reportError("completeS3ShareUploadRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.completeS3ShareUploadRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateShareUploadChannelRequest struct {
	ctx                             context.Context
	ApiService                      *PublicAPIService
	accessKey                       string
	createShareUploadChannelRequest *CreateShareUploadChannelRequest
}

func (r ApiCreateShareUploadChannelRequest) CreateShareUploadChannelRequest(createShareUploadChannelRequest CreateShareUploadChannelRequest) ApiCreateShareUploadChannelRequest {
	r.createShareUploadChannelRequest = &createShareUploadChannelRequest
	return r
}

func (r ApiCreateShareUploadChannelRequest) Execute() (*CreateShareUploadChannelResponse, *http.Response, error) {
	return r.ApiService.CreateShareUploadChannelExecute(r)
}

/*
CreateShareUploadChannel Create new file upload channel

### Description:
Create a new upload channel.

### Precondition:
None.

### Postcondition:
Upload channel is created and corresponding upload URL, token & upload ID are returned.

### Further Information:
Use `uploadUrl` the upload `token` is deprecated.

Please provide the size of the intended upload so that the quota can be checked in advanced and no data is transferred unnecessarily.

### Node naming convention:
* Node (room, folder, file) names are limited to **150** characters.
* Illegal names:
`'CON', 'PRN', 'AUX', 'NUL', 'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6', 'COM7', 'COM8', 'COM9', 'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9', (and any of those with an extension)`
* Illegal characters in names:
`'\\', '<','>', ':', '\"', '|', '?', '*', '/', leading '-', trailing '.' `

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accessKey Access key
	@return ApiCreateShareUploadChannelRequest
*/
func (a *PublicAPIService) CreateShareUploadChannel(ctx context.Context, accessKey string) ApiCreateShareUploadChannelRequest {
	return ApiCreateShareUploadChannelRequest{
		ApiService: a,
		ctx:        ctx,
		accessKey:  accessKey,
	}
}

// Execute executes the request
//
//	@return CreateShareUploadChannelResponse
func (a *PublicAPIService) CreateShareUploadChannelExecute(r ApiCreateShareUploadChannelRequest) (*CreateShareUploadChannelResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateShareUploadChannelResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.CreateShareUploadChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/public/shares/uploads/{access_key}"
	localVarPath = strings.Replace(localVarPath, "{"+"access_key"+"}", url.PathEscape(parameterValueToString(r.accessKey, "accessKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createShareUploadChannelRequest == nil {
		return localVarReturnValue, nil, reportError("createShareUploadChannelRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createShareUploadChannelRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 504 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 507 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadFileViaTokenPublicRequest struct {
	ctx             context.Context
	ApiService      *PublicAPIService
	accessKey       string
	token           string
	range_          *string
	genericMimetype *bool
	inline          *bool
}

// Range   e.g. &#x60;bytes&#x3D;0-999&#x60;
func (r ApiDownloadFileViaTokenPublicRequest) Range_(range_ string) ApiDownloadFileViaTokenPublicRequest {
	r.range_ = &range_
	return r
}

// Always return &#x60;application/octet-stream&#x60; instead of specific mimetype
func (r ApiDownloadFileViaTokenPublicRequest) GenericMimetype(genericMimetype bool) ApiDownloadFileViaTokenPublicRequest {
	r.genericMimetype = &genericMimetype
	return r
}

// Use Content-Disposition: &#x60;inline&#x60; instead of &#x60;attachment&#x60;
func (r ApiDownloadFileViaTokenPublicRequest) Inline(inline bool) ApiDownloadFileViaTokenPublicRequest {
	r.inline = &inline
	return r
}

func (r ApiDownloadFileViaTokenPublicRequest) Execute() (*http.Response, error) {
	return r.ApiService.DownloadFileViaTokenPublicExecute(r)
}

/*
DownloadFileViaTokenPublic Download file with token

### Description:
Download a file (or zip archive if target is a folder or room).

### Precondition:
Valid download token.

### Postcondition:
Stream is returned.

### Further Information:
Range requests are supported.
Range requests are illegal for zip archive download.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accessKey Access key
	@param token Download token
	@return ApiDownloadFileViaTokenPublicRequest
*/
func (a *PublicAPIService) DownloadFileViaTokenPublic(ctx context.Context, accessKey string, token string) ApiDownloadFileViaTokenPublicRequest {
	return ApiDownloadFileViaTokenPublicRequest{
		ApiService: a,
		ctx:        ctx,
		accessKey:  accessKey,
		token:      token,
	}
}

// Execute executes the request
func (a *PublicAPIService) DownloadFileViaTokenPublicExecute(r ApiDownloadFileViaTokenPublicRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.DownloadFileViaTokenPublic")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/public/shares/downloads/{access_key}/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"access_key"+"}", url.PathEscape(parameterValueToString(r.accessKey, "accessKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.genericMimetype != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "generic_mimetype", r.genericMimetype, "")
	}
	if r.inline != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inline", r.inline, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.range_ != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Range", r.range_, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 416 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDownloadFileViaTokenPublic1Request struct {
	ctx             context.Context
	ApiService      *PublicAPIService
	accessKey       string
	token           string
	range_          *string
	genericMimetype *bool
	inline          *bool
}

// Range   e.g. &#x60;bytes&#x3D;0-999&#x60;
func (r ApiDownloadFileViaTokenPublic1Request) Range_(range_ string) ApiDownloadFileViaTokenPublic1Request {
	r.range_ = &range_
	return r
}

// Always return &#x60;application/octet-stream&#x60; instead of specific mimetype
func (r ApiDownloadFileViaTokenPublic1Request) GenericMimetype(genericMimetype bool) ApiDownloadFileViaTokenPublic1Request {
	r.genericMimetype = &genericMimetype
	return r
}

// Use Content-Disposition: &#x60;inline&#x60; instead of &#x60;attachment&#x60;
func (r ApiDownloadFileViaTokenPublic1Request) Inline(inline bool) ApiDownloadFileViaTokenPublic1Request {
	r.inline = &inline
	return r
}

func (r ApiDownloadFileViaTokenPublic1Request) Execute() (*http.Response, error) {
	return r.ApiService.DownloadFileViaTokenPublic1Execute(r)
}

/*
DownloadFileViaTokenPublic1 Download file with token

### Description:
Download a file (or zip archive if target is a folder or room).

### Precondition:
Valid download token.

### Postcondition:
Stream is returned.

### Further Information:
Range requests are supported.
Range requests are illegal for zip archive download.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accessKey Access key
	@param token Download token
	@return ApiDownloadFileViaTokenPublic1Request
*/
func (a *PublicAPIService) DownloadFileViaTokenPublic1(ctx context.Context, accessKey string, token string) ApiDownloadFileViaTokenPublic1Request {
	return ApiDownloadFileViaTokenPublic1Request{
		ApiService: a,
		ctx:        ctx,
		accessKey:  accessKey,
		token:      token,
	}
}

// Execute executes the request
func (a *PublicAPIService) DownloadFileViaTokenPublic1Execute(r ApiDownloadFileViaTokenPublic1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodHead
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.DownloadFileViaTokenPublic1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/public/shares/downloads/{access_key}/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"access_key"+"}", url.PathEscape(parameterValueToString(r.accessKey, "accessKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.genericMimetype != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "generic_mimetype", r.genericMimetype, "")
	}
	if r.inline != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inline", r.inline, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.range_ != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Range", r.range_, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 416 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGenerateDownloadUrlPublicRequest struct {
	ctx                                context.Context
	ApiService                         *PublicAPIService
	accessKey                          string
	publicDownloadTokenGenerateRequest *PublicDownloadTokenGenerateRequest
}

func (r ApiGenerateDownloadUrlPublicRequest) PublicDownloadTokenGenerateRequest(publicDownloadTokenGenerateRequest PublicDownloadTokenGenerateRequest) ApiGenerateDownloadUrlPublicRequest {
	r.publicDownloadTokenGenerateRequest = &publicDownloadTokenGenerateRequest
	return r
}

func (r ApiGenerateDownloadUrlPublicRequest) Execute() (*PublicDownloadTokenGenerateResponse, *http.Response, error) {
	return r.ApiService.GenerateDownloadUrlPublicExecute(r)
}

/*
GenerateDownloadUrlPublic Generate download URL

### Description:
Generate a download URL to retrieve a shared file.

### Precondition:
None.

### Postcondition:
Download URL and token are generated and returned.

### Further Information:
Use `downloadUrl` the download `token` is deprecated.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accessKey Access key
	@return ApiGenerateDownloadUrlPublicRequest
*/
func (a *PublicAPIService) GenerateDownloadUrlPublic(ctx context.Context, accessKey string) ApiGenerateDownloadUrlPublicRequest {
	return ApiGenerateDownloadUrlPublicRequest{
		ApiService: a,
		ctx:        ctx,
		accessKey:  accessKey,
	}
}

// Execute executes the request
//
//	@return PublicDownloadTokenGenerateResponse
func (a *PublicAPIService) GenerateDownloadUrlPublicExecute(r ApiGenerateDownloadUrlPublicRequest) (*PublicDownloadTokenGenerateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PublicDownloadTokenGenerateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.GenerateDownloadUrlPublic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/public/shares/downloads/{access_key}"
	localVarPath = strings.Replace(localVarPath, "{"+"access_key"+"}", url.PathEscape(parameterValueToString(r.accessKey, "accessKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.publicDownloadTokenGenerateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGeneratePresignedUrlsPublicRequest struct {
	ctx                          context.Context
	ApiService                   *PublicAPIService
	accessKey                    string
	uploadId                     string
	generatePresignedUrlsRequest *GeneratePresignedUrlsRequest
	xSdsDateFormat               *string
}

func (r ApiGeneratePresignedUrlsPublicRequest) GeneratePresignedUrlsRequest(generatePresignedUrlsRequest GeneratePresignedUrlsRequest) ApiGeneratePresignedUrlsPublicRequest {
	r.generatePresignedUrlsRequest = &generatePresignedUrlsRequest
	return r
}

// Date time format (cf. [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) &amp; [leettime.de](http://leettime.de/))
func (r ApiGeneratePresignedUrlsPublicRequest) XSdsDateFormat(xSdsDateFormat string) ApiGeneratePresignedUrlsPublicRequest {
	r.xSdsDateFormat = &xSdsDateFormat
	return r
}

func (r ApiGeneratePresignedUrlsPublicRequest) Execute() (*PresignedUrlList, *http.Response, error) {
	return r.ApiService.GeneratePresignedUrlsPublicExecute(r)
}

/*
GeneratePresignedUrlsPublic Generate presigned URLs for S3 file upload

<h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.15.0</h3>

### Description:
Generate presigned URLs for S3 file upload.

### Precondition:
Valid upload ID

### Postcondition:
List of presigned URLs is returned.

### Further Information:
The size for each part must be >= 5 MB, except for the last part.
The part number of the first part in S3 is 1 (not 0).
Use HTTP method `PUT` for uploading bytes via presigned URL.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accessKey Access key
	@param uploadId Upload channel ID
	@return ApiGeneratePresignedUrlsPublicRequest
*/
func (a *PublicAPIService) GeneratePresignedUrlsPublic(ctx context.Context, accessKey string, uploadId string) ApiGeneratePresignedUrlsPublicRequest {
	return ApiGeneratePresignedUrlsPublicRequest{
		ApiService: a,
		ctx:        ctx,
		accessKey:  accessKey,
		uploadId:   uploadId,
	}
}

// Execute executes the request
//
//	@return PresignedUrlList
func (a *PublicAPIService) GeneratePresignedUrlsPublicExecute(r ApiGeneratePresignedUrlsPublicRequest) (*PresignedUrlList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PresignedUrlList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.GeneratePresignedUrlsPublic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/public/shares/uploads/{access_key}/{upload_id}/s3_urls"
	localVarPath = strings.Replace(localVarPath, "{"+"access_key"+"}", url.PathEscape(parameterValueToString(r.accessKey, "accessKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"upload_id"+"}", url.PathEscape(parameterValueToString(r.uploadId, "uploadId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.generatePresignedUrlsRequest == nil {
		return localVarReturnValue, nil, reportError("generatePresignedUrlsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xSdsDateFormat != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Sds-Date-Format", r.xSdsDateFormat, "")
	}
	// body params
	localVarPostBody = r.generatePresignedUrlsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 504 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 507 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRequestActiveDirectoryAuthInfoRequest struct {
	ctx               context.Context
	ApiService        *PublicAPIService
	isGlobalAvailable *bool
}

// Show only global available items
func (r ApiRequestActiveDirectoryAuthInfoRequest) IsGlobalAvailable(isGlobalAvailable bool) ApiRequestActiveDirectoryAuthInfoRequest {
	r.isGlobalAvailable = &isGlobalAvailable
	return r
}

func (r ApiRequestActiveDirectoryAuthInfoRequest) Execute() (*ActiveDirectoryAuthInfo, *http.Response, error) {
	return r.ApiService.RequestActiveDirectoryAuthInfoExecute(r)
}

/*
RequestActiveDirectoryAuthInfo Request Active Directory authentication information

### Description:
Provides information about Active Directory authentication options.

### Precondition:
None.

### Postcondition:
Active Directory authentication options information is returned.

### Further Information:
None.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRequestActiveDirectoryAuthInfoRequest
*/
func (a *PublicAPIService) RequestActiveDirectoryAuthInfo(ctx context.Context) ApiRequestActiveDirectoryAuthInfoRequest {
	return ApiRequestActiveDirectoryAuthInfoRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ActiveDirectoryAuthInfo
func (a *PublicAPIService) RequestActiveDirectoryAuthInfoExecute(r ApiRequestActiveDirectoryAuthInfoRequest) (*ActiveDirectoryAuthInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ActiveDirectoryAuthInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.RequestActiveDirectoryAuthInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/public/system/info/auth/ad"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.isGlobalAvailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_global_available", r.isGlobalAvailable, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRequestOpenIdAuthInfoRequest struct {
	ctx               context.Context
	ApiService        *PublicAPIService
	isGlobalAvailable *bool
}

// Show only global available items
func (r ApiRequestOpenIdAuthInfoRequest) IsGlobalAvailable(isGlobalAvailable bool) ApiRequestOpenIdAuthInfoRequest {
	r.isGlobalAvailable = &isGlobalAvailable
	return r
}

func (r ApiRequestOpenIdAuthInfoRequest) Execute() (*OpenIdAuthInfo, *http.Response, error) {
	return r.ApiService.RequestOpenIdAuthInfoExecute(r)
}

/*
RequestOpenIdAuthInfo Request OpenID Connect provider authentication information

### Description:
Provides information about OpenID Connect authentication options.

### Precondition:
None.

### Postcondition:
OpenID Connect authentication options information is returned.

### Further Information:
None.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRequestOpenIdAuthInfoRequest
*/
func (a *PublicAPIService) RequestOpenIdAuthInfo(ctx context.Context) ApiRequestOpenIdAuthInfoRequest {
	return ApiRequestOpenIdAuthInfoRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return OpenIdAuthInfo
func (a *PublicAPIService) RequestOpenIdAuthInfoExecute(r ApiRequestOpenIdAuthInfoRequest) (*OpenIdAuthInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OpenIdAuthInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.RequestOpenIdAuthInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/public/system/info/auth/openid"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.isGlobalAvailable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_global_available", r.isGlobalAvailable, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRequestPublicDownloadShareInfoRequest struct {
	ctx            context.Context
	ApiService     *PublicAPIService
	accessKey      string
	xSdsDateFormat *string
}

// Date time format (cf. [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) &amp; [leettime.de](http://leettime.de/))
func (r ApiRequestPublicDownloadShareInfoRequest) XSdsDateFormat(xSdsDateFormat string) ApiRequestPublicDownloadShareInfoRequest {
	r.xSdsDateFormat = &xSdsDateFormat
	return r
}

func (r ApiRequestPublicDownloadShareInfoRequest) Execute() (*PublicDownloadShare, *http.Response, error) {
	return r.ApiService.RequestPublicDownloadShareInfoExecute(r)
}

/*
RequestPublicDownloadShareInfo Request public Download Share information

### Description:
Retrieve the public information of a Download Share.

### Precondition:
None.

### Postcondition:
Download Share information is returned.

### Further Information:
None.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accessKey Access key
	@return ApiRequestPublicDownloadShareInfoRequest
*/
func (a *PublicAPIService) RequestPublicDownloadShareInfo(ctx context.Context, accessKey string) ApiRequestPublicDownloadShareInfoRequest {
	return ApiRequestPublicDownloadShareInfoRequest{
		ApiService: a,
		ctx:        ctx,
		accessKey:  accessKey,
	}
}

// Execute executes the request
//
//	@return PublicDownloadShare
func (a *PublicAPIService) RequestPublicDownloadShareInfoExecute(r ApiRequestPublicDownloadShareInfoRequest) (*PublicDownloadShare, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PublicDownloadShare
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.RequestPublicDownloadShareInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/public/shares/downloads/{access_key}"
	localVarPath = strings.Replace(localVarPath, "{"+"access_key"+"}", url.PathEscape(parameterValueToString(r.accessKey, "accessKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xSdsDateFormat != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Sds-Date-Format", r.xSdsDateFormat, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRequestPublicUploadShareInfoRequest struct {
	ctx               context.Context
	ApiService        *PublicAPIService
	accessKey         string
	xSdsSharePassword *string
	xSdsDateFormat    *string
}

// Upload share password. Should be base64-encoded.  Plain X-Sds-Share-Passwords are *deprecated* and will be removed in the future
func (r ApiRequestPublicUploadShareInfoRequest) XSdsSharePassword(xSdsSharePassword string) ApiRequestPublicUploadShareInfoRequest {
	r.xSdsSharePassword = &xSdsSharePassword
	return r
}

// Date time format (cf. [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) &amp; [leettime.de](http://leettime.de/))
func (r ApiRequestPublicUploadShareInfoRequest) XSdsDateFormat(xSdsDateFormat string) ApiRequestPublicUploadShareInfoRequest {
	r.xSdsDateFormat = &xSdsDateFormat
	return r
}

func (r ApiRequestPublicUploadShareInfoRequest) Execute() (*PublicUploadShare, *http.Response, error) {
	return r.ApiService.RequestPublicUploadShareInfoExecute(r)
}

/*
RequestPublicUploadShareInfo Request public Upload Share information

### Description:
Provides information about the desired Upload Share.

### Precondition:
Only `userUserPublicKeyList` is returned to the users who owns one of the following permissions: <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage download share</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage upload share</span>

### Postcondition:
None.

### Further Information:
If no password is set, the returned information is reduced to the following attributes (if available):

* `name`
* `createdAt`
* `isProtected`
* `isEncrypted`
* `showUploadedFiles`
* `userUserPublicKeyList` (if parent is end-to-end encrypted)

Only if the password is transmitted as `X-Sds-Share-Password` header, all values are returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accessKey Access key
	@return ApiRequestPublicUploadShareInfoRequest
*/
func (a *PublicAPIService) RequestPublicUploadShareInfo(ctx context.Context, accessKey string) ApiRequestPublicUploadShareInfoRequest {
	return ApiRequestPublicUploadShareInfoRequest{
		ApiService: a,
		ctx:        ctx,
		accessKey:  accessKey,
	}
}

// Execute executes the request
//
//	@return PublicUploadShare
func (a *PublicAPIService) RequestPublicUploadShareInfoExecute(r ApiRequestPublicUploadShareInfoRequest) (*PublicUploadShare, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PublicUploadShare
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.RequestPublicUploadShareInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/public/shares/uploads/{access_key}"
	localVarPath = strings.Replace(localVarPath, "{"+"access_key"+"}", url.PathEscape(parameterValueToString(r.accessKey, "accessKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xSdsSharePassword != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Sds-Share-Password", r.xSdsSharePassword, "")
	}
	if r.xSdsDateFormat != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Sds-Date-Format", r.xSdsDateFormat, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRequestSoftwareVersionRequest struct {
	ctx            context.Context
	ApiService     *PublicAPIService
	xSdsDateFormat *string
}

// Date time format (cf. [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) &amp; [leettime.de](http://leettime.de/))
func (r ApiRequestSoftwareVersionRequest) XSdsDateFormat(xSdsDateFormat string) ApiRequestSoftwareVersionRequest {
	r.xSdsDateFormat = &xSdsDateFormat
	return r
}

func (r ApiRequestSoftwareVersionRequest) Execute() (*SoftwareVersionData, *http.Response, error) {
	return r.ApiService.RequestSoftwareVersionExecute(r)
}

/*
RequestSoftwareVersion Request software version information

### Description:
Public software version information.

### Precondition:
None.

### Postcondition:
Sofware version information is returned.

### Further Information:
The version of DRACOON Server consists of two components:
* **API**
* **Core** (referred to as _"Server"_)

which are versioned individually.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRequestSoftwareVersionRequest
*/
func (a *PublicAPIService) RequestSoftwareVersion(ctx context.Context) ApiRequestSoftwareVersionRequest {
	return ApiRequestSoftwareVersionRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SoftwareVersionData
func (a *PublicAPIService) RequestSoftwareVersionExecute(r ApiRequestSoftwareVersionRequest) (*SoftwareVersionData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SoftwareVersionData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.RequestSoftwareVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/public/software/version"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xSdsDateFormat != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Sds-Date-Format", r.xSdsDateFormat, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRequestSystemInfoRequest struct {
	ctx        context.Context
	ApiService *PublicAPIService
	isEnabled  *bool
}

// Show only enabled authentication methods
func (r ApiRequestSystemInfoRequest) IsEnabled(isEnabled bool) ApiRequestSystemInfoRequest {
	r.isEnabled = &isEnabled
	return r
}

func (r ApiRequestSystemInfoRequest) Execute() (*SystemInfo, *http.Response, error) {
	return r.ApiService.RequestSystemInfoExecute(r)
}

/*
RequestSystemInfo Request system information

### Description:
Provides information about system.

### Precondition:
None.

### Postcondition:
System information is returned.

### Further Information:
Authentication methods are sorted by **priority** attribute.
Smaller values have higher priority.
Authentication method with the highest priority is considered as default.

### System information:
<details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
<summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>

| Setting                 | Description                                             | Value            |
|:------------------------|:--------------------------------------------------------|:-----------------|
| `languageDefault`       | Defines which language should be default.               | `ISO 639-1 code` |
| `hideLoginInputFields`  | Defines if login fields should be hidden.               | `true or false`  |
| `s3Hosts`               | List of available S3 hosts.                             | `String array`   |
| `s3EnforceDirectUpload` | Determines whether S3 direct upload is enforced or not. | `true or false`  |
| `useS3Storage`          | Determines whether S3 Storage enabled and used.         | `true or false`  |

</details>

### Authentication methods:
<details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
<summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>

| Authentication Method  | Description                                                                                                                                                                         |
|:-----------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `basic`                | **Basic** authentication globally allowed.<br>This option **MUST** be activated to allow users to log in with their credentials stored in the database.<br>Formerly known as `sql`. |
| `active_directory`     | **Active Directory** authentication globally allowed.<br>This option **MUST** be activated to allow users to log in with their Active Directory credentials.                        |
| `openid`               | **OpenID Connect** authentication globally allowed.This option **MUST** be activated to allow users to log in with their OpenID Connect identity.                                   |
| `hideLoginInputFields` | Determines whether input fields for login should be enabled                                                                                                                         |

</details>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRequestSystemInfoRequest
*/
func (a *PublicAPIService) RequestSystemInfo(ctx context.Context) ApiRequestSystemInfoRequest {
	return ApiRequestSystemInfoRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SystemInfo
func (a *PublicAPIService) RequestSystemInfoExecute(r ApiRequestSystemInfoRequest) (*SystemInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SystemInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.RequestSystemInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/public/system/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.isEnabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_enabled", r.isEnabled, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRequestSystemTimeRequest struct {
	ctx            context.Context
	ApiService     *PublicAPIService
	xSdsDateFormat *string
}

// Date time format (cf. [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) &amp; [leettime.de](http://leettime.de/))
func (r ApiRequestSystemTimeRequest) XSdsDateFormat(xSdsDateFormat string) ApiRequestSystemTimeRequest {
	r.xSdsDateFormat = &xSdsDateFormat
	return r
}

func (r ApiRequestSystemTimeRequest) Execute() (*SdsServerTime, *http.Response, error) {
	return r.ApiService.RequestSystemTimeExecute(r)
}

/*
RequestSystemTime Request system time

### Description:
Retrieve the actual server time.

### Precondition:
None.

### Postcondition:
Server time is returned.

### Further Information:
None.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRequestSystemTimeRequest
*/
func (a *PublicAPIService) RequestSystemTime(ctx context.Context) ApiRequestSystemTimeRequest {
	return ApiRequestSystemTimeRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SdsServerTime
func (a *PublicAPIService) RequestSystemTimeExecute(r ApiRequestSystemTimeRequest) (*SdsServerTime, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SdsServerTime
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.RequestSystemTime")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/public/time"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xSdsDateFormat != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Sds-Date-Format", r.xSdsDateFormat, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRequestThirdPartyDependenciesRequest struct {
	ctx        context.Context
	ApiService *PublicAPIService
}

func (r ApiRequestThirdPartyDependenciesRequest) Execute() ([]ThirdPartyDependenciesData, *http.Response, error) {
	return r.ApiService.RequestThirdPartyDependenciesExecute(r)
}

/*
RequestThirdPartyDependencies Request third-party software dependencies

<h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.9.0</h3>

### Description:
Provides information about used third-party software dependencies.

### Precondition:
None.

### Postcondition:
List of the third-party software dependencies used by **DRACOON Core** (referred to as _"Server"_) is returned.

### Further Information:
None.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRequestThirdPartyDependenciesRequest
*/
func (a *PublicAPIService) RequestThirdPartyDependencies(ctx context.Context) ApiRequestThirdPartyDependenciesRequest {
	return ApiRequestThirdPartyDependenciesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []ThirdPartyDependenciesData
func (a *PublicAPIService) RequestThirdPartyDependenciesExecute(r ApiRequestThirdPartyDependenciesRequest) ([]ThirdPartyDependenciesData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ThirdPartyDependenciesData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.RequestThirdPartyDependencies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/public/software/third_party_dependencies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRequestUploadStatusPublicRequest struct {
	ctx        context.Context
	ApiService *PublicAPIService
	accessKey  string
	uploadId   string
}

func (r ApiRequestUploadStatusPublicRequest) Execute() (*S3ShareUploadStatus, *http.Response, error) {
	return r.ApiService.RequestUploadStatusPublicExecute(r)
}

/*
RequestUploadStatusPublic Request status of S3 file upload

<h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.15.0</h3>

### Description:
Request status of a S3 file upload.

### Precondition:
An upload channel has been created and the user has <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; create</span> permissions in the parent container (room or folder).

### Postcondition:
Status of S3 multipart upload request is returned.

### Further Information:
None.

### Possible errors:
<details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
<summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>

| Http Status | Error Code | Description |
| :--- | :--- | :--- |
| `400 Bad Request` | `-80000` | Mandatory fields cannot be empty |
| `400 Bad Request` | `-80001` | Invalid positive number |
| `400 Bad Request` | `-80002` | Invalid number |
| `400 Bad Request` | `-40001` | (Target) room is not encrypted |
| `400 Bad Request` | `-40755` | Bad file name |
| `400 Bad Request` | `-40763` | File key must be set for an upload into encrypted room |
| `400 Bad Request` | `-50506` | Exceeds the number of files for this Upload Share |
| `403 Forbidden` |  | Access denied |
| `404 Not Found` | `-20501` | Upload not found |
| `404 Not Found` | `-40000` | Container not found |
| `404 Not Found` | `-41000` | Node not found |
| `404 Not Found` | `-70501` | User not found |
| `409 Conflict` | `-40010` | Container cannot be overwritten |
| `409 Conflict` |  | File cannot be overwritten |
| `500 Internal Server Error` |  | System Error |
| `502 Bad Gateway` |  | S3 Error |
| `502 Insufficient Storage` | `-50504` | Exceeds the quota for this Upload Share |
| `502 Insufficient Storage` | `-40200` | Exceeds the free node quota in room |
| `502 Insufficient Storage` | `-90200` | Exceeds the free customer quota |

</details>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accessKey Access key
	@param uploadId Upload channel ID
	@return ApiRequestUploadStatusPublicRequest
*/
func (a *PublicAPIService) RequestUploadStatusPublic(ctx context.Context, accessKey string, uploadId string) ApiRequestUploadStatusPublicRequest {
	return ApiRequestUploadStatusPublicRequest{
		ApiService: a,
		ctx:        ctx,
		accessKey:  accessKey,
		uploadId:   uploadId,
	}
}

// Execute executes the request
//
//	@return S3ShareUploadStatus
func (a *PublicAPIService) RequestUploadStatusPublicExecute(r ApiRequestUploadStatusPublicRequest) (*S3ShareUploadStatus, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *S3ShareUploadStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.RequestUploadStatusPublic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/public/shares/uploads/{access_key}/{upload_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"access_key"+"}", url.PathEscape(parameterValueToString(r.accessKey, "accessKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"upload_id"+"}", url.PathEscape(parameterValueToString(r.uploadId, "uploadId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUploadFileAsMultipartPublic1Request struct {
	ctx            context.Context
	ApiService     *PublicAPIService
	accessKey      string
	uploadId       string
	file           *os.File
	contentRange   *string
	xSdsDateFormat *string
}

// File
func (r ApiUploadFileAsMultipartPublic1Request) File(file *os.File) ApiUploadFileAsMultipartPublic1Request {
	r.file = file
	return r
}

// Content-Range   e.g. &#x60;bytes 0-999/3980&#x60;
func (r ApiUploadFileAsMultipartPublic1Request) ContentRange(contentRange string) ApiUploadFileAsMultipartPublic1Request {
	r.contentRange = &contentRange
	return r
}

// Date time format (cf. [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) &amp; [leettime.de](http://leettime.de/))
func (r ApiUploadFileAsMultipartPublic1Request) XSdsDateFormat(xSdsDateFormat string) ApiUploadFileAsMultipartPublic1Request {
	r.xSdsDateFormat = &xSdsDateFormat
	return r
}

func (r ApiUploadFileAsMultipartPublic1Request) Execute() (*ChunkUploadResponse, *http.Response, error) {
	return r.ApiService.UploadFileAsMultipartPublic1Execute(r)
}

/*
UploadFileAsMultipartPublic1 Upload file

### Description:
Chunked upload of files via Upload Share.

### Precondition:
Valid upload ID.

### Postcondition:
Chunk of file is uploaded.

### Further Information:
Chunked uploads (range requests) are supported.

Following `Content-Types` are supported by this API:
* `multipart/form-data`
* provided `Content-Type`

For both file upload types set the correct `Content-Type` header and body.

### Examples:

* `multipart/form-data`
```
POST /api/v4/public/shares/uploads/{access_key}{upload_id} HTTP/1.1

Header:
...
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW
...

Body:
------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="file"; filename="file.txt"
Content-Type: text/plain

Content of file.txt
------WebKitFormBoundary7MA4YWxkTrZu0gW--
```

* any other `Content-Type`
```
POST /api/v4/public/shares/uploads/{access_key}{upload_id} HTTP/1.1

Header:
...
Content-Type: { ... }
...

Body:
raw content
```

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accessKey Access key
	@param uploadId Upload channel ID
	@return ApiUploadFileAsMultipartPublic1Request
*/
func (a *PublicAPIService) UploadFileAsMultipartPublic1(ctx context.Context, accessKey string, uploadId string) ApiUploadFileAsMultipartPublic1Request {
	return ApiUploadFileAsMultipartPublic1Request{
		ApiService: a,
		ctx:        ctx,
		accessKey:  accessKey,
		uploadId:   uploadId,
	}
}

// Execute executes the request
//
//	@return ChunkUploadResponse
func (a *PublicAPIService) UploadFileAsMultipartPublic1Execute(r ApiUploadFileAsMultipartPublic1Request) (*ChunkUploadResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ChunkUploadResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicAPIService.UploadFileAsMultipartPublic1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/public/shares/uploads/{access_key}/{upload_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"access_key"+"}", url.PathEscape(parameterValueToString(r.accessKey, "accessKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"upload_id"+"}", url.PathEscape(parameterValueToString(r.uploadId, "uploadId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.file == nil {
		return localVarReturnValue, nil, reportError("file is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.contentRange != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Range", r.contentRange, "")
	}
	if r.xSdsDateFormat != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Sds-Date-Format", r.xSdsDateFormat, "")
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName string
	var fileLocalVarFileBytes []byte

	fileLocalVarFormFileName = "file"
	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 507 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
