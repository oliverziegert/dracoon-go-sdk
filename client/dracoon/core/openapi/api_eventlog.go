/*
DRACOON API

REST Web Services for DRACOON<br><br>This page provides an overview of all available and documented DRACOON APIs, which are grouped by tags.<br>Each tag provides a collection of APIs that are intended for a specific area of the DRACOON.<br><br><a title='Developer Information' href='https://developer.dracoon.com'>Developer Information</a>&emsp;&emsp;<a title='Get SDKs on GitHub' href='https://github.com/dracoon'>Get SDKs on GitHub</a><br><br><a title='Terms of service' href='https://www.dracoon.com/terms/general-terms-and-conditions/'>Terms of service</a>

API version: 5.3.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)

// EventlogAPIService EventlogAPI service
type EventlogAPIService service

type ApiRequestAuditNodeInfoRequest struct {
	ctx           context.Context
	ApiService    *EventlogAPIService
	parentId      *int64
	offset        *int32
	limit         *int32
	filter        *string
	sort          *string
	xSdsAuthToken *string
}

// Parent node ID.  Only rooms can be parents.  Parent ID &#x60;0&#x60; or empty is the root node.
func (r ApiRequestAuditNodeInfoRequest) ParentId(parentId int64) ApiRequestAuditNodeInfoRequest {
	r.parentId = &parentId
	return r
}

// Range offset
func (r ApiRequestAuditNodeInfoRequest) Offset(offset int32) ApiRequestAuditNodeInfoRequest {
	r.offset = &offset
	return r
}

// Range limit.  Maximum 500.   For more results please use paging (&#x60;offset&#x60; + &#x60;limit&#x60;).
func (r ApiRequestAuditNodeInfoRequest) Limit(limit int32) ApiRequestAuditNodeInfoRequest {
	r.limit = &limit
	return r
}

// Filter string
func (r ApiRequestAuditNodeInfoRequest) Filter(filter string) ApiRequestAuditNodeInfoRequest {
	r.filter = &filter
	return r
}

// Sort string
func (r ApiRequestAuditNodeInfoRequest) Sort(sort string) ApiRequestAuditNodeInfoRequest {
	r.sort = &sort
	return r
}

// Authentication token
func (r ApiRequestAuditNodeInfoRequest) XSdsAuthToken(xSdsAuthToken string) ApiRequestAuditNodeInfoRequest {
	r.xSdsAuthToken = &xSdsAuthToken
	return r
}

func (r ApiRequestAuditNodeInfoRequest) Execute() (*AuditNodeInfoResponse, *http.Response, error) {
	return r.ApiService.RequestAuditNodeInfoExecute(r)
}

/*
RequestAuditNodeInfo Request nodes

<h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.31.0</h3>

### Description:
Retrieve a list of all nodes of type room under a certain parent.

### Precondition:
Right <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read audit log</span> required.

### Postcondition:
List of rooms.

### Further Information:
For rooms on root level, use parent_id = 0.

### Filtering:
All filter fields are connected via logical conjunction (**AND**)
Filter string syntax: `FIELD_NAME:OPERATOR:VALUE[:VALUE...]`

<details style="padding-left: 10px">
<summary style="cursor: pointer; outline: none"><strong>Example</strong></summary>

`nodeName:cn:searchString_1|nodeIsEncrypted:eq:true`
Filter by node name containing `searchString_1` **AND** node is encrypted .

</details>

### Filtering options:
<details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
<summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>

| `FIELD_NAME` | Filter Description | `OPERATOR` | Operator Description | `VALUE` |
| :--- | :--- | :--- | :--- | :--- |
| `nodeId` | Node ID filter | `eq` | Node ID equals value. | `positive Integer` |
| `nodeName` | Node name filter | `cn, eq, sw` | Node name contains / equals / starts with value. | `search String` |
| `nodeIsEncrypted` | Encrypted node filter | `eq` |  | `true or false` |

</details>

---

### Sorting:
Sort string syntax: `FIELD_NAME:ORDER`
`ORDER` can be `asc` or `desc`.
Multiple sort fields are supported.

<details style="padding-left: 10px">
<summary style="cursor: pointer; outline: none"><strong>Example</strong></summary>

`nodeName:asc`
Sort by `nodeName` ascending.

</details>

### Sorting options:
<details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
<summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>

| `FIELD_NAME` | Description |
| :--- | :--- |
| `nodeId` | Node ID |
| `nodeName` | Node name |

</details>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRequestAuditNodeInfoRequest
*/
func (a *EventlogAPIService) RequestAuditNodeInfo(ctx context.Context) ApiRequestAuditNodeInfoRequest {
	return ApiRequestAuditNodeInfoRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AuditNodeInfoResponse
func (a *EventlogAPIService) RequestAuditNodeInfoExecute(r ApiRequestAuditNodeInfoRequest) (*AuditNodeInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuditNodeInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventlogAPIService.RequestAuditNodeInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/eventlog/audits/node_info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_id", r.parentId, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xSdsAuthToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Sds-Auth-Token", r.xSdsAuthToken, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRequestAuditNodeUserDataRequest struct {
	ctx            context.Context
	ApiService     *EventlogAPIService
	xSdsDateFormat *string
	offset         *int32
	limit          *int32
	filter         *string
	sort           *string
	xSdsAuthToken  *string
}

// Date time format (cf. [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) &amp; [leettime.de](http://leettime.de/))
func (r ApiRequestAuditNodeUserDataRequest) XSdsDateFormat(xSdsDateFormat string) ApiRequestAuditNodeUserDataRequest {
	r.xSdsDateFormat = &xSdsDateFormat
	return r
}

// Range offset
func (r ApiRequestAuditNodeUserDataRequest) Offset(offset int32) ApiRequestAuditNodeUserDataRequest {
	r.offset = &offset
	return r
}

// Range limit.  Maximum 500.   For more results please use paging (&#x60;offset&#x60; + &#x60;limit&#x60;).
func (r ApiRequestAuditNodeUserDataRequest) Limit(limit int32) ApiRequestAuditNodeUserDataRequest {
	r.limit = &limit
	return r
}

// Filter string
func (r ApiRequestAuditNodeUserDataRequest) Filter(filter string) ApiRequestAuditNodeUserDataRequest {
	r.filter = &filter
	return r
}

// Sort string
func (r ApiRequestAuditNodeUserDataRequest) Sort(sort string) ApiRequestAuditNodeUserDataRequest {
	r.sort = &sort
	return r
}

// Authentication token
func (r ApiRequestAuditNodeUserDataRequest) XSdsAuthToken(xSdsAuthToken string) ApiRequestAuditNodeUserDataRequest {
	r.xSdsAuthToken = &xSdsAuthToken
	return r
}

func (r ApiRequestAuditNodeUserDataRequest) Execute() ([]AuditNodeResponse, *http.Response, error) {
	return r.ApiService.RequestAuditNodeUserDataExecute(r)
}

/*
RequestAuditNodeUserData Request node assigned users with permissions

<h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128679; Deprecated since v4.32.0</h3>

### Description:
Retrieve a list of all nodes of type room, and the room assignment users with permissions.

### Precondition:
Right <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read audit log</span> required.

### Postcondition:
List of rooms and their assigned users is returned.

### Further Information:

Output is limited to **500** entries.
For more results please use filter criteria and the `limit` parameter.

### Filtering:
All filter fields are connected via logical conjunction (**AND**)
Except for `userName`, `userFirstName` and  `userLastName` - these are connected via logical disjunction (**OR**)
Filter string syntax: `FIELD_NAME:OPERATOR:VALUE[:VALUE...]`

<details style="padding-left: 10px">
<summary style="cursor: pointer; outline: none"><strong>Example</strong></summary>

`userName:cn:searchString_1|userFirstName:cn:searchString_2|nodeId:eq:2`
Filter by user login containing `searchString_1` **OR** first name containing `searchString_2` **AND** node ID equals `2`.

</details>

### Filtering options:
<details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
<summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>

| `FIELD_NAME` | Filter Description | `OPERATOR` | Operator Description | `VALUE` |
| :--- | :--- | :--- | :--- | :--- |
| `nodeId` | Node ID filter | `eq` | Node ID equals value. | `positive Integer` |
| `nodeName` | Node name filter | `cn, eq` | Node name contains / equals value. | `search String` |
| `nodeParentId` | Node parent ID filter | `eq` | Parent ID equals value. | `positive Integer`<br>Parent ID `0` is the root node. |
| `userId` | User ID filter | `eq` | User ID equals value. | `positive Integer` |
| `userName` | Username (login) filter | `cn, eq` | Username contains / equals value. | `search String` |
| `userFirstName` | User first name filter | `cn, eq` | User first name contains / equals value. | `search String` |
| `userLastName` | User last name filter | `cn, eq` | User last name contains / equals value. | `search String` |
| `permissionsManage` | Filter the users that do (not) have `manage` permissions in this room | `eq` |  | `true or false` |
| `nodeIsEncrypted` | Encrypted node filter | `eq` |  | `true or false` |
| `nodeHasActivitiesLog` | Activities log filter | `eq` |  | `true or false` |

</details>

### Deprecated filtering options:
<details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
<summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>

| `FIELD_NAME` | Filter Description | `OPERATOR` | Operator Description | `VALUE` |
| :--- | :--- | :--- | :--- | :--- |
| <del>`nodeHasRecycleBin`</del> | Recycle bin filter<br>**Filter has no effect!** | `eq` |  | `true or false` |

</details>

---

### Sorting:
Sort string syntax: `FIELD_NAME:ORDER`
`ORDER` can be `asc` or `desc`.
Multiple sort fields are supported.

<details style="padding-left: 10px">
<summary style="cursor: pointer; outline: none"><strong>Example</strong></summary>

`nodeName:asc`
Sort by `nodeName` ascending.

</details>

### Sorting options:
<details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
<summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>

| `FIELD_NAME` | Description |
| :--- | :--- |
| `nodeId` | Node ID |
| `nodeName` | Node name |
| `nodeParentId` | Node parent ID |
| `nodeSize` | Node size |
| `nodeQuota` | Node quota |

</details>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRequestAuditNodeUserDataRequest

Deprecated
*/
func (a *EventlogAPIService) RequestAuditNodeUserData(ctx context.Context) ApiRequestAuditNodeUserDataRequest {
	return ApiRequestAuditNodeUserDataRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []AuditNodeResponse
//
// Deprecated
func (a *EventlogAPIService) RequestAuditNodeUserDataExecute(r ApiRequestAuditNodeUserDataRequest) ([]AuditNodeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []AuditNodeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventlogAPIService.RequestAuditNodeUserData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/eventlog/audits/nodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xSdsDateFormat != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Sds-Date-Format", r.xSdsDateFormat, "")
	}
	if r.xSdsAuthToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Sds-Auth-Token", r.xSdsAuthToken, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRequestLogEventsAsJsonRequest struct {
	ctx            context.Context
	ApiService     *EventlogAPIService
	xSdsDateFormat *string
	sort           *string
	offset         *int32
	limit          *int32
	dateStart      *string
	dateEnd        *string
	type_          *int32
	userId         *int64
	status         *string
	userClient     *string
	xSdsAuthToken  *string
}

// Date time format (cf. [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) &amp; [leettime.de](http://leettime.de/))
func (r ApiRequestLogEventsAsJsonRequest) XSdsDateFormat(xSdsDateFormat string) ApiRequestLogEventsAsJsonRequest {
	r.xSdsDateFormat = &xSdsDateFormat
	return r
}

// Sort string
func (r ApiRequestLogEventsAsJsonRequest) Sort(sort string) ApiRequestLogEventsAsJsonRequest {
	r.sort = &sort
	return r
}

// Range offset
func (r ApiRequestLogEventsAsJsonRequest) Offset(offset int32) ApiRequestLogEventsAsJsonRequest {
	r.offset = &offset
	return r
}

// Range limit.  Maximum 500.   For more results please use paging (&#x60;offset&#x60; + &#x60;limit&#x60;).
func (r ApiRequestLogEventsAsJsonRequest) Limit(limit int32) ApiRequestLogEventsAsJsonRequest {
	r.limit = &limit
	return r
}

// Filter events from given date   e.g. &#x60;2015-12-31T23:59:00&#x60;
func (r ApiRequestLogEventsAsJsonRequest) DateStart(dateStart string) ApiRequestLogEventsAsJsonRequest {
	r.dateStart = &dateStart
	return r
}

// Filter events until given date   e.g. &#x60;2015-12-31T23:59:00&#x60;
func (r ApiRequestLogEventsAsJsonRequest) DateEnd(dateEnd string) ApiRequestLogEventsAsJsonRequest {
	r.dateEnd = &dateEnd
	return r
}

// Operation ID   cf. &#x60;GET /eventlog/operations&#x60;
func (r ApiRequestLogEventsAsJsonRequest) Type_(type_ int32) ApiRequestLogEventsAsJsonRequest {
	r.type_ = &type_
	return r
}

// User ID
func (r ApiRequestLogEventsAsJsonRequest) UserId(userId int64) ApiRequestLogEventsAsJsonRequest {
	r.userId = &userId
	return r
}

// Operation status:  * &#x60;0&#x60; - Success  * &#x60;2&#x60; - Error
func (r ApiRequestLogEventsAsJsonRequest) Status(status string) ApiRequestLogEventsAsJsonRequest {
	r.status = &status
	return r
}

// User client
func (r ApiRequestLogEventsAsJsonRequest) UserClient(userClient string) ApiRequestLogEventsAsJsonRequest {
	r.userClient = &userClient
	return r
}

// Authentication token
func (r ApiRequestLogEventsAsJsonRequest) XSdsAuthToken(xSdsAuthToken string) ApiRequestLogEventsAsJsonRequest {
	r.xSdsAuthToken = &xSdsAuthToken
	return r
}

func (r ApiRequestLogEventsAsJsonRequest) Execute() (*LogEventList, *http.Response, error) {
	return r.ApiService.RequestLogEventsAsJsonExecute(r)
}

/*
RequestLogEventsAsJson Request system events

<h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.3.0</h3>

### Description:
Retrieve eventlog (audit log) events.

### Precondition:
Role <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Log Auditor</span> required.

### Postcondition:
List of audit log events is returned.

### Further Information:
Output is limited to **500** entries.
For more results please use filter criteria and paging (`offset` + `limit`).

Allowed `Accept-Header`:
* `Accept: application/json`
* `Accept: text/csv`

---

Sort string syntax: `FIELD_NAME:ORDER`
`ORDER` can be `asc` or `desc`.
Multiple sort fields are supported.

<details style="padding-left: 10px">
<summary style="cursor: pointer; outline: none"><strong>Example</strong></summary>

`time:desc`
Sort by `time` descending (default sort option).

</details>

### Sorting options:
<details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
<summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>

| `FIELD_NAME` | Description |
| :--- | :--- |
| `time` | Event timestamp |

</details>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRequestLogEventsAsJsonRequest
*/
func (a *EventlogAPIService) RequestLogEventsAsJson(ctx context.Context) ApiRequestLogEventsAsJsonRequest {
	return ApiRequestLogEventsAsJsonRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return LogEventList
func (a *EventlogAPIService) RequestLogEventsAsJsonExecute(r ApiRequestLogEventsAsJsonRequest) (*LogEventList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LogEventList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventlogAPIService.RequestLogEventsAsJson")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/eventlog/events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.dateStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_start", r.dateStart, "")
	}
	if r.dateEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_end", r.dateEnd, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_id", r.userId, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.userClient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_client", r.userClient, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xSdsDateFormat != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Sds-Date-Format", r.xSdsDateFormat, "")
	}
	if r.xSdsAuthToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Sds-Auth-Token", r.xSdsAuthToken, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRequestLogOperationsRequest struct {
	ctx           context.Context
	ApiService    *EventlogAPIService
	isDeprecated  *bool
	xSdsAuthToken *string
}

// Show only deprecated operations
func (r ApiRequestLogOperationsRequest) IsDeprecated(isDeprecated bool) ApiRequestLogOperationsRequest {
	r.isDeprecated = &isDeprecated
	return r
}

// Authentication token
func (r ApiRequestLogOperationsRequest) XSdsAuthToken(xSdsAuthToken string) ApiRequestLogOperationsRequest {
	r.xSdsAuthToken = &xSdsAuthToken
	return r
}

func (r ApiRequestLogOperationsRequest) Execute() (*LogOperationList, *http.Response, error) {
	return r.ApiService.RequestLogOperationsExecute(r)
}

/*
RequestLogOperations Request allowed Log Operations

<h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.3.0</h3>

### Description:
Retrieve eventlog (audit log) operation IDs and the associated log operation description.

### Precondition:
Role <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Log Auditor</span> required.

### Postcondition:
List of available log operations is returned.

### Further Information:
None.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRequestLogOperationsRequest
*/
func (a *EventlogAPIService) RequestLogOperations(ctx context.Context) ApiRequestLogOperationsRequest {
	return ApiRequestLogOperationsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return LogOperationList
func (a *EventlogAPIService) RequestLogOperationsExecute(r ApiRequestLogOperationsRequest) (*LogOperationList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LogOperationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventlogAPIService.RequestLogOperations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/eventlog/operations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.isDeprecated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_deprecated", r.isDeprecated, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xSdsAuthToken != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Sds-Auth-Token", r.xSdsAuthToken, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
